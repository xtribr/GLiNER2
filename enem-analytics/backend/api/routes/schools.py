"""
School endpoints for ENEM Analytics API
"""

from fastapi import APIRouter, Query, HTTPException
from typing import Optional, List, Dict
from pydantic import BaseModel
import pandas as pd
import os
import requests

router = APIRouter()

# Cache for skills data
_skills_df = None

# PowerBI API config for school-specific skills
POWERBI_API_URL = "https://wabi-brazil-south-b-primary-api.analysis.windows.net/public/reports/querydata?synchronous=true"
POWERBI_MODEL_ID = 6606248
POWERBI_DATASET_ID = "68135bd6-e83c-419b-90e2-64bdb5553961"
POWERBI_REPORT_ID = "e93cdfb7-4848-4123-b9f7-b075ec852dfc"
POWERBI_HEADERS = {
    "Accept": "application/json, text/plain, */*",
    "Content-Type": "application/json;charset=UTF-8",
    "Origin": "https://app.powerbi.com",
    "Referer": "https://app.powerbi.com/",
    "X-PowerBI-ResourceKey": "95131326-e9de-47c4-8bf5-12c27c1e113a",
}

# Skill descriptions
SKILL_DESCRIPTIONS = {
    "CN": {
        1: "Compreender fenômenos naturais usando conceitos científicos",
        2: "Associar sistemas físicos, químicos e biológicos a processos naturais",
        3: "Enfrentar situações-problema usando conhecimentos científicos",
        4: "Compreender o papel da evolução na diversidade biológica",
        5: "Avaliar o impacto de intervenções humanas no ambiente",
        6: "Interpretar experimentos científicos e seus resultados",
        7: "Analisar e compreender conceitos de genética e hereditariedade",
        8: "Compreender processos de transformação de energia",
        9: "Avaliar mudanças de estado físico e transformações químicas",
        10: "Compreender a dinâmica de ecossistemas e cadeias alimentares",
        11: "Analisar fenômenos eletromagnéticos e suas aplicações",
        12: "Compreender processos de obtenção de materiais e substâncias",
        13: "Avaliar propostas de intervenção no meio ambiente",
        14: "Compreender a célula como unidade básica da vida",
        15: "Analisar fenômenos ondulatórios e suas propriedades",
        16: "Compreender processos metabólicos e bioquímicos",
        17: "Avaliar aspectos quantitativos de transformações químicas",
        18: "Compreender movimento, forças e leis de Newton",
        19: "Analisar processos de nutrição e digestão",
        20: "Compreender o sistema nervoso e seus processos",
        21: "Analisar fenômenos térmicos e termodinâmicos",
        22: "Compreender ciclos biogeoquímicos",
        23: "Avaliar impactos ambientais de atividades humanas",
        24: "Compreender processos de reprodução e desenvolvimento",
        25: "Analisar a relação entre tecnologia e ciência",
        26: "Compreender o funcionamento do sistema imunológico",
        27: "Analisar doenças e medidas de prevenção",
        28: "Compreender a origem e evolução do universo",
        29: "Analisar o uso de recursos naturais e sustentabilidade",
        30: "Compreender processos de fotossíntese e respiração celular",
    },
    "CH": {
        1: "Compreender a produção e o papel histórico das instituições sociais",
        2: "Analisar a atuação dos movimentos sociais na transformação da realidade",
        3: "Compreender conflitos gerados pela diversidade cultural",
        4: "Avaliar relações de poder entre grupos sociais",
        5: "Identificar transformações territoriais e paisagens",
        6: "Compreender processos de formação do Estado brasileiro",
        7: "Analisar o papel da mídia na sociedade contemporânea",
        8: "Compreender fatores que contribuíram para revoluções históricas",
        9: "Analisar processos migratórios e seus impactos",
        10: "Compreender organizações políticas e sistemas de governo",
        11: "Analisar desigualdades sociais e seus determinantes",
        12: "Compreender processo de urbanização e problemas urbanos",
        13: "Avaliar impactos da globalização econômica e cultural",
        14: "Analisar formação e caracterização de blocos econômicos",
        15: "Compreender aspectos geográficos de conflitos contemporâneos",
        16: "Analisar processos de industrialização e impactos",
        17: "Compreender relações entre trabalho e sociedade",
        18: "Analisar períodos históricos do Brasil",
        19: "Compreender formação cultural brasileira e identidade nacional",
        20: "Avaliar propostas de intervenção em problemas sociais",
        21: "Compreender questões ambientais e desenvolvimento sustentável",
        22: "Analisar a questão agrária brasileira e conflitos no campo",
        23: "Compreender processos de colonização e descolonização",
        24: "Analisar aspectos do trabalho no mundo contemporâneo",
        25: "Compreender dinâmicas demográficas e suas consequências",
        26: "Analisar a expansão marítima e comercial europeia",
        27: "Compreender processos de independência na América",
        28: "Analisar regimes autoritários e processos de democratização",
        29: "Compreender a formação dos Estados nacionais",
        30: "Analisar movimentos culturais e artísticos ao longo da história",
    },
    "LC": {
        1: "Identificar diferentes linguagens e seus contextos de uso",
        2: "Reconhecer a função social de diferentes gêneros textuais",
        3: "Analisar relações entre textos e seus contextos",
        4: "Reconhecer posicionamentos ideológicos em textos",
        5: "Avaliar argumentos em textos de diferentes gêneros",
        6: "Compreender propostas de intervenção social através de textos",
        7: "Relacionar linguagens verbal e não verbal",
        8: "Reconhecer o uso de figuras de linguagem e seus efeitos",
        9: "Compreender variações linguísticas e seus contextos",
        10: "Analisar recursos expressivos das linguagens artísticas",
        11: "Reconhecer estratégias argumentativas em textos",
        12: "Compreender a função social da literatura",
        13: "Analisar aspectos formais e estruturais de textos",
        14: "Identificar elementos que concorrem para a progressão temática",
        15: "Estabelecer relações entre textos de diferentes gêneros",
        16: "Reconhecer procedimentos de convencimento em textos",
        17: "Analisar a produção artística como expressão cultural",
        18: "Compreender manifestações corporais e práticas esportivas",
        19: "Avaliar o papel da mídia na construção de realidades",
        20: "Analisar a função estética em produções culturais",
        21: "Compreender textos técnicos e científicos",
        22: "Reconhecer recursos de coesão e coerência textual",
        23: "Analisar aspectos da língua portuguesa em uso",
        24: "Compreender processos de formação de palavras",
        25: "Avaliar a adequação linguística em diferentes contextos",
        26: "Analisar produções culturais de diferentes épocas",
        27: "Compreender o papel da tecnologia na comunicação",
        28: "Reconhecer diferentes formas de organização textual",
        29: "Avaliar processos de criação artística e cultural",
        30: "Compreender relações intertextuais e suas funções",
    },
    "MT": {
        1: "Construir significados para números naturais, inteiros e racionais",
        2: "Utilizar conhecimentos geométricos na resolução de problemas",
        3: "Selecionar estratégias de resolução de problemas",
        4: "Analisar dados apresentados em gráficos e tabelas",
        5: "Avaliar propostas de intervenção usando conceitos matemáticos",
        6: "Interpretar informações em diferentes representações matemáticas",
        7: "Compreender o caráter aleatório de fenômenos naturais e sociais",
        8: "Resolver problemas envolvendo grandezas proporcionais",
        9: "Utilizar instrumentos de medida e escalas",
        10: "Analisar informações expressas em gráficos e tabelas",
        11: "Utilizar noções de proporcionalidade e semelhança",
        12: "Resolver problemas envolvendo equações e inequações",
        13: "Avaliar modelos matemáticos usados em contextos reais",
        14: "Analisar problemas envolvendo variação de grandezas",
        15: "Identificar regularidades e padrões matemáticos",
        16: "Utilizar conceitos de geometria analítica",
        17: "Compreender aplicações de razões trigonométricas",
        18: "Resolver problemas de contagem e probabilidade",
        19: "Avaliar propostas de tratamento de dados estatísticos",
        20: "Analisar problemas envolvendo funções matemáticas",
        21: "Utilizar conceitos de geometria espacial",
        22: "Resolver problemas envolvendo sequências numéricas",
        23: "Analisar situações envolvendo matemática financeira",
        24: "Compreender aplicações de matrizes e determinantes",
        25: "Resolver problemas usando sistemas de equações",
        26: "Analisar gráficos de funções",
        27: "Utilizar conceitos de geometria plana",
        28: "Resolver problemas de otimização",
        29: "Avaliar argumentos matemáticos e demonstrações",
        30: "Compreender aplicações de polinômios e suas propriedades",
    },
}


def get_skills_df():
    """Load skills data from CSV"""
    global _skills_df
    if _skills_df is None:
        skills_path = os.path.join(os.path.dirname(__file__), "..", "..", "data", "habilidades_2024.csv")
        if os.path.exists(skills_path):
            _skills_df = pd.read_csv(skills_path)
    return _skills_df


def fetch_school_skills_from_powerbi(codigo_inep: str) -> List[Dict]:
    """Fetch skills data for a specific school from PowerBI API"""
    query = {
        "version": "1.0.0",
        "queries": [{
            "Query": {
                "Commands": [{
                    "SemanticQueryDataShapeCommand": {
                        "Query": {
                            "Version": 2,
                            "From": [
                                {"Name": "c", "Entity": "cur-enem-school-skill", "Type": 0},
                                {"Name": "s", "Entity": "stg-senso-escolar", "Type": 0},
                                {"Name": "e", "Entity": "enem_area", "Type": 0},
                                {"Name": "f", "Entity": "filtro_tamanho", "Type": 0},
                                {"Name": "co", "Entity": "comparação", "Type": 0}
                            ],
                            "Select": [
                                {
                                    "Column": {
                                        "Expression": {"SourceRef": {"Source": "e"}},
                                        "Property": "area"
                                    },
                                    "Name": "area"
                                },
                                {
                                    "Column": {
                                        "Expression": {"SourceRef": {"Source": "c"}},
                                        "Property": "co_habilidade"
                                    },
                                    "Name": "habilidade"
                                },
                                {
                                    "Aggregation": {
                                        "Expression": {
                                            "Column": {
                                                "Expression": {"SourceRef": {"Source": "c"}},
                                                "Property": "desempenho_hab"
                                            }
                                        },
                                        "Function": 1
                                    },
                                    "Name": "desempenho"
                                }
                            ],
                            "Where": [
                                {
                                    "Condition": {
                                        "In": {
                                            "Expressions": [{"Column": {"Expression": {"SourceRef": {"Source": "s"}}, "Property": "ano"}}],
                                            "Values": [[{"Literal": {"Value": "2024L"}}]]
                                        }
                                    }
                                },
                                {
                                    "Condition": {
                                        "In": {
                                            "Expressions": [{"Column": {"Expression": {"SourceRef": {"Source": "f"}}, "Property": "nome"}}],
                                            "Values": [[{"Literal": {"Value": "'Todas escolas'"}}]]
                                        }
                                    }
                                },
                                {
                                    "Condition": {
                                        "In": {
                                            "Expressions": [{"Column": {"Expression": {"SourceRef": {"Source": "co"}}, "Property": "Coluna 1"}}],
                                            "Values": [[{"Literal": {"Value": "'Brasil'"}}]]
                                        }
                                    }
                                },
                                {
                                    "Condition": {
                                        "StartsWith": {
                                            "Left": {"Column": {"Expression": {"SourceRef": {"Source": "s"}}, "Property": "inep_nome"}},
                                            "Right": {"Literal": {"Value": f"'{codigo_inep}'"}}
                                        }
                                    }
                                }
                            ]
                        },
                        "Binding": {
                            "Primary": {"Groupings": [{"Projections": [0, 1, 2]}]},
                            "DataReduction": {"DataVolume": 5, "Primary": {"Window": {"Count": 500}}},
                            "Version": 1
                        },
                        "ExecutionMetricsKind": 1
                    }
                }]
            },
            "QueryId": "",
            "ApplicationContext": {"DatasetId": POWERBI_DATASET_ID, "Sources": [{"ReportId": POWERBI_REPORT_ID}]}
        }],
        "cancelQueries": [],
        "modelId": POWERBI_MODEL_ID
    }

    try:
        response = requests.post(POWERBI_API_URL, headers=POWERBI_HEADERS, json=query, timeout=30)
        response.raise_for_status()
        data = response.json()

        # Parse response
        ds = data["results"][0]["result"]["data"]["dsr"]["DS"][0]
        value_dicts = ds.get("ValueDicts", {})
        area_names = value_dicts.get("D0", [])

        records = []
        current_area = None

        for ph in ds.get("PH", []):
            for row in ph.get("DM0", []):
                if "C" not in row:
                    continue
                values = row["C"]
                repeat = row.get("R")

                if len(values) == 3:
                    area_idx = values[0]
                    skill_num = values[1]
                    perf = float(values[2])
                    current_area = area_names[area_idx] if area_idx < len(area_names) else f"Area{area_idx}"
                elif len(values) == 2 and repeat == 1:
                    skill_num = values[0]
                    perf = float(values[1])
                else:
                    continue

                records.append({
                    "area": current_area,
                    "skill_num": int(skill_num),
                    "performance": round(perf * 100, 1),
                    "descricao": SKILL_DESCRIPTIONS.get(current_area, {}).get(skill_num, f"Habilidade {skill_num}")
                })

        return records

    except Exception as e:
        print(f"Error fetching school skills: {e}")
        return []


class SchoolScore(BaseModel):
    ano: int
    nota_cn: Optional[float] = None
    nota_ch: Optional[float] = None
    nota_lc: Optional[float] = None
    nota_mt: Optional[float] = None
    nota_redacao: Optional[float] = None
    nota_media: Optional[float] = None
    ranking_brasil: Optional[int] = None
    desempenho_habilidades: Optional[float] = None
    competencia_redacao_media: Optional[float] = None


class SchoolSummary(BaseModel):
    codigo_inep: str
    nome_escola: str
    uf: Optional[str] = None
    tipo_escola: Optional[str] = None
    localizacao: Optional[str] = None
    porte: Optional[int] = None
    porte_label: Optional[str] = None
    qt_matriculas: Optional[int] = None
    ultimo_ranking: Optional[int] = None
    ultima_nota: Optional[float] = None
    anos_participacao: int


class SchoolDetail(BaseModel):
    codigo_inep: str
    nome_escola: str
    uf: Optional[str] = None
    tipo_escola: Optional[str] = None
    historico: List[SchoolScore]
    tendencia: Optional[str] = None
    melhor_ano: Optional[int] = None
    melhor_ranking: Optional[int] = None


def get_df():
    """Import here to avoid circular imports"""
    from api.main import get_dataframe
    return get_dataframe()


@router.get("/", response_model=List[SchoolSummary])
async def list_schools(
    page: int = Query(1, ge=1),
    limit: int = Query(50, ge=1, le=200),
    search: Optional[str] = None,
    uf: Optional[str] = None,
    tipo_escola: Optional[str] = None,
    localizacao: Optional[str] = None,
    porte: Optional[int] = None,
    ano: Optional[int] = None,
    order_by: str = Query("ranking", regex="^(ranking|nota|nome)$"),
    order: str = Query("asc", regex="^(asc|desc)$")
):
    """
    List schools with pagination and filtering

    Filters:
    - uf: State code (e.g., SP, RJ, CE)
    - tipo_escola: "Privada" or "Pública"
    - localizacao: "Urbana" or "Rural"
    - porte: 1-5 (1=Muito pequena, 2=Pequena, 3=Média, 4=Grande, 5=Muito grande)
    - search: Search by name or INEP code
    """
    df = get_df()
    if df is None:
        raise HTTPException(status_code=500, detail="Data not loaded")

    # Filter by year (default to most recent)
    target_ano = ano or int(df["ano"].max())
    df_year = df[df["ano"] == target_ano].copy()

    # Apply filters
    if search:
        search_lower = search.lower()
        df_year = df_year[
            df_year["nome_escola"].str.lower().str.contains(search_lower, na=False) |
            df_year["codigo_inep"].str.contains(search, na=False)
        ]

    if uf:
        df_year = df_year[df_year["uf"] == uf.upper()]

    if tipo_escola:
        df_year = df_year[df_year["tipo_escola"] == tipo_escola]

    if localizacao:
        df_year = df_year[df_year["localizacao"] == localizacao]

    if porte:
        df_year = df_year[df_year["porte"] == porte]

    # Sort
    if order_by == "ranking":
        sort_col = "ranking_brasil"
        df_year = df_year.dropna(subset=["ranking_brasil"])
    elif order_by == "nota":
        sort_col = "nota_media"
    else:
        sort_col = "nome_escola"

    ascending = order == "asc"
    df_year = df_year.sort_values(sort_col, ascending=ascending)

    # Pagination
    total = len(df_year)
    start = (page - 1) * limit
    end = start + limit
    df_page = df_year.iloc[start:end]

    # Build response
    results = []
    for _, row in df_page.iterrows():
        anos_count = int(df[df["codigo_inep"] == row["codigo_inep"]]["ano"].nunique())
        results.append(SchoolSummary(
            codigo_inep=str(row["codigo_inep"]),
            nome_escola=str(row["nome_escola"]),
            uf=str(row["uf"]) if pd.notna(row.get("uf")) else None,
            tipo_escola=str(row["tipo_escola"]) if pd.notna(row.get("tipo_escola")) else None,
            localizacao=str(row["localizacao"]) if pd.notna(row.get("localizacao")) else None,
            porte=int(row["porte"]) if pd.notna(row.get("porte")) else None,
            porte_label=str(row["porte_label"]) if pd.notna(row.get("porte_label")) else None,
            qt_matriculas=int(row["qt_matriculas"]) if pd.notna(row.get("qt_matriculas")) else None,
            ultimo_ranking=int(row["ranking_brasil"]) if pd.notna(row.get("ranking_brasil")) else None,
            ultima_nota=float(round(row["nota_media"], 2)) if pd.notna(row.get("nota_media")) else None,
            anos_participacao=anos_count
        ))

    return results


@router.get("/top")
async def get_top_schools(
    ano: Optional[int] = None,
    limit: int = Query(10, ge=1, le=100),
    uf: Optional[str] = None,
    tipo_escola: Optional[str] = None,
    localizacao: Optional[str] = None,
    porte: Optional[int] = None
):
    """
    Get top ranked schools

    Filters:
    - uf: State code (e.g., SP, RJ, CE)
    - tipo_escola: "Privada" or "Pública"
    - localizacao: "Urbana" or "Rural"
    - porte: 1-5 (1=Muito pequena, 2=Pequena, 3=Média, 4=Grande, 5=Muito grande)
    """
    df = get_df()
    if df is None:
        raise HTTPException(status_code=500, detail="Data not loaded")

    target_ano = ano or int(df["ano"].max())
    df_year = df[df["ano"] == target_ano].copy()

    if uf:
        df_year = df_year[df_year["uf"] == uf.upper()]

    if tipo_escola:
        df_year = df_year[df_year["tipo_escola"] == tipo_escola]

    if localizacao:
        df_year = df_year[df_year["localizacao"] == localizacao]

    if porte:
        df_year = df_year[df_year["porte"] == porte]

    # Sort by ranking
    df_year = df_year.dropna(subset=["ranking_brasil"])
    df_year = df_year.sort_values("ranking_brasil", ascending=True)
    df_top = df_year.head(limit)

    results = []
    for _, row in df_top.iterrows():
        results.append({
            "ranking": int(row["ranking_brasil"]),
            "codigo_inep": str(row["codigo_inep"]),
            "nome_escola": str(row["nome_escola"]),
            "uf": str(row["uf"]) if pd.notna(row.get("uf")) else None,
            "tipo_escola": str(row["tipo_escola"]) if pd.notna(row.get("tipo_escola")) else None,
            "localizacao": str(row["localizacao"]) if pd.notna(row.get("localizacao")) else None,
            "porte": int(row["porte"]) if pd.notna(row.get("porte")) else None,
            "porte_label": str(row["porte_label"]) if pd.notna(row.get("porte_label")) else None,
            "qt_matriculas": int(row["qt_matriculas"]) if pd.notna(row.get("qt_matriculas")) else None,
            "nota_media": float(round(row["nota_media"], 2)) if pd.notna(row.get("nota_media")) else None,
            "nota_cn": float(round(row["nota_cn"], 2)) if pd.notna(row.get("nota_cn")) else None,
            "nota_ch": float(round(row["nota_ch"], 2)) if pd.notna(row.get("nota_ch")) else None,
            "nota_lc": float(round(row["nota_lc"], 2)) if pd.notna(row.get("nota_lc")) else None,
            "nota_mt": float(round(row["nota_mt"], 2)) if pd.notna(row.get("nota_mt")) else None,
            "nota_redacao": float(round(row["nota_redacao"], 2)) if pd.notna(row.get("nota_redacao")) else None,
            "desempenho_habilidades": float(round(row["desempenho_habilidades"], 4)) if pd.notna(row.get("desempenho_habilidades")) else None,
            "competencia_redacao_media": float(round(row["competencia_redacao_media"], 2)) if pd.notna(row.get("competencia_redacao_media")) else None,
        })

    return {
        "ano": target_ano,
        "total": len(results),
        "schools": results
    }


@router.get("/search")
async def search_schools(
    q: str = Query(..., min_length=2),
    limit: int = Query(20, ge=1, le=100)
):
    """
    Quick search for schools by name or INEP code
    """
    df = get_df()
    if df is None:
        raise HTTPException(status_code=500, detail="Data not loaded")

    q_lower = q.lower()

    # Get most recent year for each school
    df_latest = df.loc[df.groupby("codigo_inep")["ano"].idxmax()]

    # Search
    matches = df_latest[
        df_latest["nome_escola"].str.lower().str.contains(q_lower, na=False) |
        df_latest["codigo_inep"].str.contains(q, na=False)
    ]

    matches = matches.head(limit)

    return [
        {
            "codigo_inep": str(row["codigo_inep"]),
            "nome_escola": str(row["nome_escola"]),
            "uf": str(row["uf"]) if pd.notna(row.get("uf")) else None,
            "ultimo_ano": int(row["ano"])
        }
        for _, row in matches.iterrows()
    ]


@router.get("/{codigo_inep}", response_model=SchoolDetail)
async def get_school(codigo_inep: str):
    """
    Get detailed information for a specific school
    """
    df = get_df()
    if df is None:
        raise HTTPException(status_code=500, detail="Data not loaded")

    df_school = df[df["codigo_inep"] == codigo_inep].copy()

    if df_school.empty:
        raise HTTPException(status_code=404, detail=f"School {codigo_inep} not found")

    df_school = df_school.sort_values("ano")

    # Build history
    historico = []
    for _, row in df_school.iterrows():
        historico.append(SchoolScore(
            ano=int(row["ano"]),
            nota_cn=float(round(row["nota_cn"], 2)) if pd.notna(row.get("nota_cn")) else None,
            nota_ch=float(round(row["nota_ch"], 2)) if pd.notna(row.get("nota_ch")) else None,
            nota_lc=float(round(row["nota_lc"], 2)) if pd.notna(row.get("nota_lc")) else None,
            nota_mt=float(round(row["nota_mt"], 2)) if pd.notna(row.get("nota_mt")) else None,
            nota_redacao=float(round(row["nota_redacao"], 2)) if pd.notna(row.get("nota_redacao")) else None,
            nota_media=float(round(row["nota_media"], 2)) if pd.notna(row.get("nota_media")) else None,
            ranking_brasil=int(row["ranking_brasil"]) if pd.notna(row.get("ranking_brasil")) else None,
            desempenho_habilidades=float(round(row["desempenho_habilidades"], 4)) if pd.notna(row.get("desempenho_habilidades")) else None,
            competencia_redacao_media=float(round(row["competencia_redacao_media"], 2)) if pd.notna(row.get("competencia_redacao_media")) else None
        ))

    # Calculate trend
    if len(df_school) >= 2:
        recent = df_school.tail(3)
        if len(recent) >= 2 and "nota_media" in recent.columns:
            first_nota = recent.iloc[0]["nota_media"]
            last_nota = recent.iloc[-1]["nota_media"]
            if pd.notna(first_nota) and pd.notna(last_nota):
                diff = last_nota - first_nota
                if diff > 10:
                    tendencia = "subindo"
                elif diff < -10:
                    tendencia = "descendo"
                else:
                    tendencia = "estável"
            else:
                tendencia = None
        else:
            tendencia = None
    else:
        tendencia = None

    # Best year
    df_with_ranking = df_school.dropna(subset=["ranking_brasil"])
    if not df_with_ranking.empty:
        best_idx = df_with_ranking["ranking_brasil"].idxmin()
        melhor_ano = int(df_with_ranking.loc[best_idx, "ano"])
        melhor_ranking = int(df_with_ranking.loc[best_idx, "ranking_brasil"])
    else:
        melhor_ano = None
        melhor_ranking = None

    latest = df_school.iloc[-1]

    return SchoolDetail(
        codigo_inep=str(codigo_inep),
        nome_escola=str(latest["nome_escola"]),
        uf=str(latest["uf"]) if pd.notna(latest.get("uf")) else None,
        tipo_escola=str(latest["tipo_escola"]) if pd.notna(latest.get("tipo_escola")) else None,
        historico=historico,
        tendencia=tendencia,
        melhor_ano=melhor_ano,
        melhor_ranking=melhor_ranking
    )


@router.get("/{codigo_inep}/history")
async def get_school_history(codigo_inep: str):
    """
    Get complete history for a school with year-over-year comparison
    """
    df = get_df()
    if df is None:
        raise HTTPException(status_code=500, detail="Data not loaded")

    df_school = df[df["codigo_inep"] == codigo_inep].copy()

    if df_school.empty:
        raise HTTPException(status_code=404, detail=f"School {codigo_inep} not found")

    df_school = df_school.sort_values("ano")
    latest = df_school.iloc[-1]

    history = []
    prev_ranking = None
    prev_nota = None

    for _, row in df_school.iterrows():
        ranking = int(row["ranking_brasil"]) if pd.notna(row.get("ranking_brasil")) else None
        nota = float(round(row["nota_media"], 2)) if pd.notna(row.get("nota_media")) else None

        # Calculate year-over-year changes
        ranking_change = None
        nota_change = None

        if ranking is not None and prev_ranking is not None:
            ranking_change = prev_ranking - ranking  # Positive = improved

        if nota is not None and prev_nota is not None:
            nota_change = float(round(nota - prev_nota, 2))

        history.append({
            "ano": int(row["ano"]),
            "ranking_brasil": ranking,
            "ranking_change": ranking_change,
            "nota_media": nota,
            "nota_change": nota_change,
            "nota_cn": float(round(row["nota_cn"], 2)) if pd.notna(row.get("nota_cn")) else None,
            "nota_ch": float(round(row["nota_ch"], 2)) if pd.notna(row.get("nota_ch")) else None,
            "nota_lc": float(round(row["nota_lc"], 2)) if pd.notna(row.get("nota_lc")) else None,
            "nota_mt": float(round(row["nota_mt"], 2)) if pd.notna(row.get("nota_mt")) else None,
            "nota_redacao": float(round(row["nota_redacao"], 2)) if pd.notna(row.get("nota_redacao")) else None,
            "desempenho_habilidades": float(round(row["desempenho_habilidades"], 4)) if pd.notna(row.get("desempenho_habilidades")) else None,
            "competencia_redacao_media": float(round(row["competencia_redacao_media"], 2)) if pd.notna(row.get("competencia_redacao_media")) else None,
        })

        prev_ranking = ranking
        prev_nota = nota

    return {
        "codigo_inep": str(codigo_inep),
        "nome_escola": str(latest["nome_escola"]),
        "uf": str(latest["uf"]) if pd.notna(latest.get("uf")) else None,
        "tipo_escola": str(latest["tipo_escola"]) if pd.notna(latest.get("tipo_escola")) else None,
        "anos_participacao": len(history),
        "history": history
    }


@router.get("/compare/{inep1}/{inep2}")
async def compare_schools(inep1: str, inep2: str):
    """
    Compare two schools side by side
    """
    df = get_df()
    if df is None:
        raise HTTPException(status_code=500, detail="Data not loaded")

    df1 = df[df["codigo_inep"] == inep1]
    df2 = df[df["codigo_inep"] == inep2]

    if df1.empty:
        raise HTTPException(status_code=404, detail=f"School {inep1} not found")
    if df2.empty:
        raise HTTPException(status_code=404, detail=f"School {inep2} not found")

    # Get common years
    years1 = set(int(y) for y in df1["ano"].tolist())
    years2 = set(int(y) for y in df2["ano"].tolist())
    common_years = sorted(years1 & years2)

    comparison = []
    for year in common_years:
        row1 = df1[df1["ano"] == year].iloc[0]
        row2 = df2[df2["ano"] == year].iloc[0]

        comparison.append({
            "ano": int(year),
            "escola1": {
                "nota_media": float(round(row1["nota_media"], 2)) if pd.notna(row1.get("nota_media")) else None,
                "ranking": int(row1["ranking_brasil"]) if pd.notna(row1.get("ranking_brasil")) else None,
            },
            "escola2": {
                "nota_media": float(round(row2["nota_media"], 2)) if pd.notna(row2.get("nota_media")) else None,
                "ranking": int(row2["ranking_brasil"]) if pd.notna(row2.get("ranking_brasil")) else None,
            }
        })

    latest1 = df1.iloc[-1]
    latest2 = df2.iloc[-1]

    return {
        "escola1": {
            "codigo_inep": str(inep1),
            "nome_escola": str(latest1["nome_escola"]),
            "uf": str(latest1["uf"]) if pd.notna(latest1.get("uf")) else None
        },
        "escola2": {
            "codigo_inep": str(inep2),
            "nome_escola": str(latest2["nome_escola"]),
            "uf": str(latest2["uf"]) if pd.notna(latest2.get("uf")) else None
        },
        "common_years": common_years,
        "comparison": comparison
    }


@router.get("/skills/worst")
async def get_worst_skills(
    area: Optional[str] = Query(None, regex="^(CN|CH|LC|MT)$"),
    limit: int = Query(10, ge=1, le=30)
):
    """
    Get the worst performing skills (most missed by students) per area.
    Returns the 10 most difficult skills for each area or a specific area.
    """
    df = get_skills_df()
    if df is None:
        raise HTTPException(status_code=500, detail="Skills data not available")

    result = {}

    areas = [area] if area else ["CN", "CH", "LC", "MT"]

    for a in areas:
        area_df = df[df["area"] == a].copy()
        # Sort by performance ascending (lowest = hardest)
        area_df = area_df.sort_values("performance", ascending=True).head(limit)

        result[a] = [
            {
                "skill_num": int(row["skill_num"]),
                "performance": round(float(row["performance"]) * 100, 1),
                "descricao": str(row["descricao"])
            }
            for _, row in area_df.iterrows()
        ]

    return {
        "ano": 2024,
        "skills_by_area": result
    }


@router.get("/skills/all")
async def get_all_skills(
    area: Optional[str] = Query(None, regex="^(CN|CH|LC|MT)$")
):
    """
    Get all skills performance data, optionally filtered by area.
    """
    df = get_skills_df()
    if df is None:
        raise HTTPException(status_code=500, detail="Skills data not available")

    if area:
        df = df[df["area"] == area]

    result = []
    for _, row in df.iterrows():
        result.append({
            "area": str(row["area"]),
            "skill_num": int(row["skill_num"]),
            "performance": round(float(row["performance"]) * 100, 1),
            "descricao": str(row["descricao"])
        })

    return {
        "ano": 2024,
        "total": len(result),
        "skills": result
    }


@router.get("/{codigo_inep}/skills")
async def get_school_skills(
    codigo_inep: str,
    limit: int = Query(10, ge=1, le=30)
):
    """
    Get skill performance for a specific school.
    Returns the worst performing skills compared to national average.
    """
    # Fetch school-specific skills from PowerBI
    school_skills = fetch_school_skills_from_powerbi(codigo_inep)

    if not school_skills:
        raise HTTPException(status_code=404, detail=f"Skills data not available for school {codigo_inep}")

    # Get national average for comparison
    national_df = get_skills_df()

    # Build response with comparison to national average
    skills_by_area = {}

    for area in ["CN", "CH", "LC", "MT"]:
        area_skills = [s for s in school_skills if s["area"] == area]
        # Sort by performance (worst first)
        area_skills.sort(key=lambda x: x["performance"])

        # Get national averages for this area
        national_area = national_df[national_df["area"] == area] if national_df is not None else None

        enriched_skills = []
        for skill in area_skills[:limit]:
            national_perf = None
            diff = None

            if national_area is not None:
                nat_skill = national_area[national_area["skill_num"] == skill["skill_num"]]
                if not nat_skill.empty:
                    national_perf = round(float(nat_skill.iloc[0]["performance"]) * 100, 1)
                    diff = round(skill["performance"] - national_perf, 1)

            enriched_skills.append({
                "skill_num": skill["skill_num"],
                "performance": skill["performance"],
                "national_avg": national_perf,
                "diff": diff,
                "descricao": skill["descricao"],
                "status": "above" if diff and diff > 0 else "below" if diff and diff < 0 else "equal"
            })

        skills_by_area[area] = enriched_skills

    # Also get overall worst skills across all areas
    all_skills_sorted = sorted(school_skills, key=lambda x: x["performance"])[:limit]
    worst_overall = []

    for skill in all_skills_sorted:
        national_perf = None
        diff = None

        if national_df is not None:
            nat_skill = national_df[(national_df["area"] == skill["area"]) & (national_df["skill_num"] == skill["skill_num"])]
            if not nat_skill.empty:
                national_perf = round(float(nat_skill.iloc[0]["performance"]) * 100, 1)
                diff = round(skill["performance"] - national_perf, 1)

        worst_overall.append({
            "area": skill["area"],
            "skill_num": skill["skill_num"],
            "performance": skill["performance"],
            "national_avg": national_perf,
            "diff": diff,
            "descricao": skill["descricao"],
            "status": "above" if diff and diff > 0 else "below" if diff and diff < 0 else "equal"
        })

    return {
        "codigo_inep": codigo_inep,
        "ano": 2024,
        "total_skills": len(school_skills),
        "worst_overall": worst_overall,
        "by_area": skills_by_area
    }
